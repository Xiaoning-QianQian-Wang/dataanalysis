
--Occupation
SELECT --NAMEORDER,
	  MAX(CASE WHEN OCCUPATION='Doctor' THEN [NAME] END) AS Doctor
	  ,MAX(CASE WHEN OCCUPATION='Actor' THEN [NAME] END) AS Actor
	  ,MAX(CASE WHEN OCCUPATION='Singer' THEN [NAME] END) AS Singer
	  ,MAX(CASE WHEN OCCUPATION='Professor' THEN [NAME] END) AS Professor
FROM(
SELECT *
      ,RANK() OVER(PARTITION BY OCCUPATION ORDER BY NAME ASC) AS NAMEORDER
FROM OCCUPATIONS) A
GROUP BY NAMEORDER

--Binary Tree Nodes
WITH A AS (SELECT B.N AS NODE
      ,B.P AS PARENT
      ,G.P AS GP
FROM BST B
LEFT JOIN BST G ON G.N=B.P)


SELECT A.NODE
      ,CASE WHEN A.PARENT IS NULL THEN 'Root'
            WHEN A.NODE NOT IN (SELECT DISTINCT PARENT FROM A WHERE PARENT IS NOT NULL) THEN 'Leaf'
            ELSE 'Inner' END nodetype
FROM A
ORDER BY A.NODE

--New Companies
WITH A AS (SELECT C.COMPANY_CODE
       ,C.FOUNDER
       ,LM.LEAD_MANAGER_CODE
       ,SM.SENIOR_MANAGER_CODE
       ,M.MANAGER_CODE
       ,E.EMPLOYEE_CODE
FROM COMPANY C
LEFT JOIN LEAD_MANAGER LM ON LM.COMPANY_CODE=C.COMPANY_CODE
LEFT JOIN SENIOR_MANAGER SM ON SM.LEAD_MANAGER_CODE=LM.LEAD_MANAGER_CODE
LEFT JOIN MANAGER M ON M.SENIOR_MANAGER_CODE=SM.SENIOR_MANAGER_CODE
LEFT JOIN EMPLOYEE E ON E.MANAGER_CODE=M.MANAGER_CODE)

SELECT COMPANY_CODE
      ,FOUNDER
      ,COUNT(DISTINCT(LEAD_MANAGER_CODE))
      ,COUNT(DISTINCT(SENIOR_MANAGER_CODE))
      ,COUNT(DISTINCT(MANAGER_CODE))
      ,COUNT(DISTINCT(EMPLOYEE_CODE))
FROM A
GROUP BY COMPANY_CODE ,FOUNDER
ORDER BY LEFT(COMPANY_CODE,1), RIGHT(COMPANY_CODE,LEN(COMPANY_CODE)-CHARINDEX('_',COMPANY_CODE))

--Weather Observation 18
SELECT
CAST(
ABS((SELECT MIN(LAT_N)
FROM STATION
)-(SELECT MAX(LAT_N)
FROM STATION))
+
ABS((SELECT MIN(LONG_W)
FROM STATION)-(SELECT MAX(LONG_W)
FROM STATION)) AS DECIMAL(12,4))

--The Report
WITH A AS (SELECT*,
    CASE WHEN (S.MARKS>= G.MIN_MARK AND S.MARKS<=G.MAX_MARK) THEN 1 ELSE NULL END AS MARKFILTER
FROM STUDENTS S
CROSS JOIN GRADES G)

SELECT NAME,GRADE,MARKS
FROM(
SELECT  CASE WHEN GRADE>=8 THEN NAME ELSE NULL END AS NAME
      ,GRADE
      ,MARKS
FROM A 
WHERE A.MARKFILTER IS NOT NULL) B
ORDER BY GRADE DESC,NAME,MARKS

--Top competitors
WITH A AS(
SELECT H.HACKER_ID
,H.NAME
,C.CHALLENGE_ID
,D.SCORE
,S.SCORE AS HACKER_SCORE
FROM HACKERS H
INNER JOIN SUBMISSIONS S ON H.HACKER_ID=S.HACKER_ID
INNER JOIN CHALLENGES C ON C.CHALLENGE_ID=S.CHALLENGE_ID
INNER JOIN DIFFICULTY D ON D.DIFFICULTY_LEVEL=C.DIFFICULTY_LEVEL
WHERE D.SCORE=S.SCORE)

SELECT HACKER_ID
      ,MAX(NAME)
      --,COUNT(CHALLENGE_ID)
FROM A
GROUP BY HACKER_ID
HAVING COUNT(CHALLENGE_ID)>1
ORDER BY COUNT(CHALLENGE_ID) DESC,HACKER_ID
--Ollivander's Inventory
SELECT W.ID
      ,WP.AGE
      ,W.COINS_NEEDED
      ,W.POWER
FROM WANDS W
INNER JOIN WANDS_PROPERTY WP ON W.CODE=WP.CODE
WHERE WP.IS_EVIL=0
AND W.COINS_NEEDED=(
SELECT MIN(P1.COINS_NEEDED)
FROM WANDS P1
INNER JOIN WANDS_PROPERTY P2 ON P1.CODE=P2.CODE
WHERE W.POWER=P1.POWER
    AND WP.AGE=P2.AGE
)
ORDER BY W.POWER DESC, WP.AGE DESC
--Challenges
WITH A AS(
SELECT H.HACKER_ID,H.NAME,COUNT(CHALLENGE_ID) AS CHALLENGE_COUNT
FROM HACKERS H
INNER JOIN CHALLENGES C ON H.HACKER_ID=C.HACKER_ID
GROUP BY H.HACKER_ID,H.NAME)

SELECT HACKER_ID,NAME,CHALLENGE_COUNT
FROM A
WHERE  A.CHALLENGE_COUNT IN 
(SELECT CHALLENGE_COUNT
FROM A
GROUP BY CHALLENGE_COUNT
HAVING COUNT(HACKER_ID)=1)
OR A.CHALLENGE_COUNT = (SELECT MAX(CHALLENGE_COUNT) FROM A)
ORDER BY CHALLENGE_COUNT DESC, HACKER_ID
--leaderboard contest
SELECT A.HACKER_ID,MAX(H.NAME),SUM(SCORE_V)
FROM (
SELECT CHALLENGE_ID,HACKER_ID,MAX(SCORE) AS SCORE_V
FROM SUBMISSIONS
GROUP BY CHALLENGE_ID,HACKER_ID) A
INNER JOIN HACKERS H ON A.HACKER_ID=H.HACKER_ID
GROUP BY A.HACKER_ID
HAVING SUM(SCORE_V)<>0
ORDER BY SUM(SCORE_V) DESC, A.HACKER_ID

--Placement
SELECT S.NAME
FROM FRIENDS F
INNER JOIN PACKAGES S1 ON F.ID=S1.ID
INNER JOIN PACKAGES S2 ON F.FRIEND_ID=S2.ID
INNER JOIN STUDENTS S ON S.ID=F.ID
WHERE S1.SALARY<S2.SALARY
ORDER BY S2.SALARY
--Pairs
SELECT X,Y
FROM (
SELECT F.X,F.Y
FROM FUNCTIONS F
LEFT JOIN FUNCTIONS F1 ON F.Y=F1.X
WHERE F.X<F.Y
AND F.X=F1.Y
UNION 
SELECT X,Y
FROM FUNCTIONS
WHERE X=Y
GROUP BY X,Y
HAVING COUNT(X)>1) A
ORDER BY X




 datediff(DAY,'2023-1-1','2023-1-2')


SELECT ISNULL(NULL,'QQ')

SELECT COALESCE(NULL,'QQ')